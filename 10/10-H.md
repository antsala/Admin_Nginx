# El módulo rewrite.

Una redirección `redirect` y una reescritura `rewrite`de URL son conceptos distintos, aunque a menudo se utilizan para propósitos similares en el contexto del servidor web y pueden llegar a confundirse.

- **Redirección de URL**: Una redirección de URL implica enviar al navegador del cliente una respuesta HTTP con un código de estado de redirección (por ejemplo, `301` o `302`) junto con la nueva URL a la que se debe dirigir. Esto indica al navegador que debe cargar la nueva URL en lugar de la solicitada originalmente. Las redirecciones son útiles para casos como mover un sitio web a una nueva ubicación permanente, redirigir versiones antiguas de una página a una nueva, o dirigir tráfico de un dominio a otro.

- **Reescritura de URL**: La reescritura de URL, por el contrario, implica ***cambiar la apariencia de la URL***. Esto puede ser útil para crear URLs más amigables para los motores de búsqueda, para mejorar la legibilidad de las URL o para adaptar las URL a una estructura de sitio web específica.

Sí, la reescritura de URL puede cambiar lo que el usuario ve en la barra de direcciones de su navegador. Cuando se utiliza la reescritura de URL, el servidor web internamente procesa la solicitud de una manera diferente a como se solicita originalmente por el usuario, pero esto puede hacerse de manera transparente y sin que el usuario sea consciente de ello.

Por ejemplo, supongamos que tenemos una URL como:

```bash
http://ejemplo.com/producto.php?id=123
```

Con la reescritura de URL, podemos modificar la apariencia de esta URL para que sea más legible y significativa para los usuarios y para los motores de búsqueda. Podríamos reescribirla de esta manera:

```bash
http://ejemplo.com/producto/123
```

Aunque internamente el servidor web sigue procesando la solicitud como `producto.php?id=123`, la reescritura de URL hace que la URL vista por el usuario ***en la barra de direcciones del navegador sea más limpia y fácil de entender***.

La reescritura del URI con la directiva `rewrite` genera una redirección interna. Por ejemplo:

```nginx
server {
    server_name website.com;
    root /var/www/vhosts/website.com/httpdocs/;
    
    location /storage/ {
        internal;  # Significa que esta ubicación solo puede ser servida desde dentro de Nginx.
        alias /var/www/storage/; # Nginx reemplaza '/storage' por '/var/www/storage' antes de servir.
    }
    
    location /documents/ {
        rewrite ^/documents/(.*)$ /storage/$1;
    }
}
```

Una consulta del cliente a:

```bash
http://website.com/documents/file.txt 
```

Coincide con el segundo bloque de ubicación (`location /documents/`). Sin embargo, el bloque contiene una instrucción de reescritura que transforma el URI de `/documents/file.txt` a `/storage/file.txt`. La transformación del URI reinicializa el proceso; el nuevo URI se compara con los bloques de ubicación. Esta vez, el primer bloque de ubicación (`location /storage/`) coincide con el URI (`/storage/file.txt`).

Esto proporciona una forma de reorganizar y servir archivos dentro del servidor de manera transparente para el cliente.

Si miramos el log de acceso (recomendado) veremos algo similar a esto:

```bash
-> http request line: "GET /documents/file.txt HTTP/1.1"
-> http uri: "/documents/file.txt"
-> test location: "/storage/"
-> test location: "/documents/"
-> using configuration "/documents/"
-> https script regex: "^/documents/(.*)$"
-> "^/documents/(.*)$" matches "/documents/file.txt", client: 127.0.0.1, server: website.com, request: "GET /documents/file.txt HTTP/1.1", host: "website.com"
-> rewritten data: "/storage/file.txt", args: "", client: 127.0.0.1, server: website.com, solicitud: "GET /documents/file.txt HTTP/1.1", host: "website.com"
-> testl ocation: "/storage/"
-> using configuration "/storage/"
-> http filename: "/var/www/storage/file.txt"
-> HTTP/1.1 200 OK
-> http output filter "/storage/file.txt?"
```

## Bucles infinitos en las reescrituras.

Esto sucede, por ejemplo, cuando nuestras reglas de reescritura son redundantes y causan redirecciones internas en un bucle infinito. Por ejemplo:

```nginx
server {
    server_name website.com;
    location /documents/ {
        rewrite ^(.*)$ /documents/2024/$1;
    }
}
```

Esta directiva `rewrite` captura toda la URI de la solicitud con `^(.*)$` y luego la reescribe para que comience con `/documents/2024/`, seguido del resto de la URI original `$1`.

Cuando Nginx recibe una solicitud que comienza con `/documents/`. La reescritura llevará a cabo la redirección interna, pero el nuevo URI generado seguirá comenzando con `/documents/`. Esto significa que, después de la reescritura, la nueva URI coincidirá nuevamente con la ubicación `/documents/`, y el proceso de reescritura se repetirá.

Por ejemplo, si una solicitud entra con la URI `/documents/file.txt`, después de la reescritura, el nuevo URI será `/documents/2024/documents/file.txt`. Pero como sigue comenzando con `/documents/`, el servidor volverá a aplicar la reescritura obteniéndose como resultado `/documents/2024/documents/2024/documents/file.txt`, y así sucesivamente, creando un bucle infinito.

## Estructuras condicionales.

El módulo `Rewrite` introduce un nuevo conjunto de directivas y bloques, entre los cuales se encuentra la estructura condicional if, esta es su sintaxis:

```nginx
server {
    if ($request_method = POST) {
        [...]
    }
}
```

Nos ofrece la posibilidad de aplicar una configuración según la condición especifica, en la que podemos usar diferentes operadores. Estos son:


- **Ninguno**, que debemos interpretarlo como no poner el operador. La condición es verdadera si la variable o los datos especificados no son iguales a una cadena vacía. Por ejemplo:

    ```nginx
    if ($string) {
        [...]
    }
    ```

- **=, !=**. La condición es verdadera si el argumento que precede al símbolo `=` es igual al argumento que le sigue. El siguiente ejemplo se puede leer como: "Si el método de solicitud es igual a `POST`, entonces aplica la configuración":

    ```nginx
    if ($request_method = POST) {
        [...]
    }
    ```
    El operador `!=` hace lo contrario: "Si el método de solicitud no es igual a `GET`, entonces aplica la configuración":

    ```nginx
    if ($request_method != GET) {
        [...]
    }
    ```

- ~, !~. La condición es verdadera si el argumento que precede al símbolo `~` coincide (o no) con el patrón de expresión regular que se coloca después de él. Por ejemplo:

    ```nginx
    if ($request_filename ~ "\.txt$") {
        [...]
    }
    ```
    `~` es sensible a mayúsculas y minúsculas, mientras que `~*` no distingue mayúsculas y minúsculas. Usamos el símbolo `!` para negar la coincidencia. Por ejemplo:

    ```nginx
    if ($request_filename !~* "\.php$") {
        [...]
    }
    ```

    Este ejemplo te muestra como usar variables en los bloques condicionales:

    ```nginx
    if ($uri ~ "^/search/(.*)$") {
        set $query $1;
        rewrite ^ http://google.com/search?q=$query;
    }
    ```
- **Operador sobre el sistema de arcivos**: `-f`, `!-f` prueba la existencia (o no) del archivo especificado. Por ejemplo:

    ```nginx
    if (-f $request_filename) {
        [...] # si el archivo existe
    }
    ```

    ```nginx
    if (!-f $request_filename) {
        [...] # si el archivo no existe
    }
    ```

    `-d`, `!-d` es se usa para probar la existencia (o no) de un directorio. `-e`, `!-e` para probar (o no) la existencia de un archivo, directorio o enlace simbólico. `-x`, `!-x` para probar (o no) si un archivo existe y es ejecutable.

Como curiosidad, es conveniente saber que no hay instrucciones como `else` o `else if` y debemos buscar esta funcionalidad sin ellas, por ejemplo, así:

```nginx
server {
    listen 80;
    server_name example.com;

    location / {
        if ($condicion) {
            # Si se cumple la condición
            # realiza acciones
        }

        if ($condicion = 0) {
            # Si la condición no se cumple
            # realiza otras acciones
        }
    }
}
```



[Vamos al siguiente contenido](./10-I.md)